--[[
    Advanced Remote Spy
    by axel ganteng
    Using Official WindUI
--]]

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Create Window
local Window = WindUI:CreateWindow({
    Title = "Remote Spy | by axel ganteng",
    Author = "by axel ganteng",
    Folder = "RemoteSpyConfig",
})

-- ========== GLOBAL VARIABLES ==========
getgenv().RemoteSpy = {
    Enabled = false,
    MonitorRemotes = true,
    AutoBlock = false,
    LogCalls = true,
    MaxLogs = 200
}

-- Data Storage
local RemoteData = {
    Logs = {},
    HookedRemotes = {},
    OriginalFunctions = {},
    FoundRemotes = {},
    SelectedRemote = nil
}

-- ========== CREATE TABS ==========
local Tabs = {
    Main = Window:Tab({Title = "Main", Icon = "home", Desc = "Main controls"}),
    Scanner = Window:Tab({Title = "Scanner", Icon = "search", Desc = "Remote scanning"}),
    RemoteManager = Window:Tab({Title = "Remotes", Icon = "list", Desc = "Remote management"}),
    Security = Window:Tab({Title = "Security", Icon = "shield", Desc = "Security settings"})
}

-- Select first tab
Window:SelectTab(1)

-- ========== MAIN TAB ==========
Tabs.Main:Section({Title = "System Status"})

local StatusLabel = Tabs.Main:Label("ðŸ”´ System: OFFLINE")

Tabs.Main:Section({Title = "Remote Spy Controls"})

local SpyToggle = Tabs.Main:Toggle({
    Title = "Enable Remote Spy",
    Default = false,
    Callback = function(Value)
        getgenv().RemoteSpy.Enabled = Value
        updateStatus()
        if Value then
            startRemoteSpy()
        else
            stopRemoteSpy()
        end
    end
})

local MonitorToggle = Tabs.Main:Toggle({
    Title = "Monitor Remote Calls",
    Default = true,
    Callback = function(Value)
        getgenv().RemoteSpy.MonitorRemotes = Value
    end
})

local BlockToggle = Tabs.Main:Toggle({
    Title = "Auto Block Suspicious",
    Default = false,
    Callback = function(Value)
        getgenv().RemoteSpy.AutoBlock = Value
    end
})

Tabs.Main:Section({Title = "Quick Actions"})

local ScanBtn = Tabs.Main:Button({
    Title = "Quick Scan",
    Callback = function()
        quickScan()
    end
})

local ClearBtn = Tabs.Main:Button({
    Title = "Clear Logs",
    Callback = function()
        clearLogs()
    end
})

-- ========== SCANNER TAB ==========
Tabs.Scanner:Section({Title = "Scanning Tools"})

local DeepScanBtn = Tabs.Scanner:Button({
    Title = "Deep Scan",
    Callback = function()
        performDeepScan()
    end
})

local ScriptScanBtn = Tabs.Scanner:Button({
    Title = "Scan Scripts",
    Callback = function()
        scanScriptsForRemotes()
    end
})

local RefreshBtn = Tabs.Scanner:Button({
    Title = "Refresh List",
    Callback = function()
        updateRemoteList()
    end
})

Tabs.Scanner:Section({Title = "Scan Results"})

local ResultsLabel = Tabs.Scanner:Label("Click 'Deep Scan' to find remotes")

-- ========== REMOTE MANAGER TAB ==========
Tabs.RemoteManager:Section({Title = "Remote Selection"})

local RemoteDropdown = Tabs.RemoteManager:Dropdown({
    Title = "Select Remote",
    Values = {"No remotes found"},
    Value = "No remotes found",
    Callback = function(Option)
        selectRemoteFromDropdown(Option)
    end
})

Tabs.RemoteManager:Section({Title = "Remote Information"})

local RemoteInfoLabel = Tabs.RemoteManager:Label("Select a remote to view info")

Tabs.RemoteManager:Section({Title = "Copy Tools"})

local CopyPathBtn = Tabs.RemoteManager:Button({
    Title = "Copy Remote Path",
    Callback = function()
        copySelectedRemotePath()
    end
})

local CopyNameBtn = Tabs.RemoteManager:Button({
    Title = "Copy Remote Name",
    Callback = function()
        copySelectedRemoteName()
    end
})

local CopyScriptBtn = Tabs.RemoteManager:Button({
    Title = "Copy Fire Script",
    Callback = function()
        copySelectedFireScript()
    end
})

-- ========== SECURITY TAB ==========
Tabs.Security:Section({Title = "Security Settings"})

local AlertToggle = Tabs.Security:Toggle({
    Title = "Alert on Suspicious",
    Default = true,
    Callback = function(Value)
        -- Alert setting
    end
})

Tabs.Security:Section({Title = "Security Actions"})

local BlockAllBtn = Tabs.Security:Button({
    Title = "Block All Remotes",
    Callback = function()
        blockAllRemotes()
    end
})

local UnblockAllBtn = Tabs.Security:Button({
    Title = "Unblock All Remotes",
    Callback = function()
        unblockAllRemotes()
    end
})

local ExportBtn = Tabs.Security:Button({
    Title = "Export Security Report",
    Callback = function()
        exportSecurityReport()
    end
})

-- ========== CORE FUNCTIONS ==========

function startRemoteSpy()
    WindUI:Notify({
        Title = "Remote Spy",
        Content = "Starting remote monitoring system...",
        Icon = "loader",
        Duration = 3
    })
    
    findAndHookAllRemotes()
    
    -- Monitor for new remotes
    game.DescendantAdded:Connect(function(obj)
        if isValidRemote(obj) then
            hookRemote(obj)
            addToFoundRemotes(obj)
            updateRemoteList()
        end
    end)
    
    updateStatus()
    
    WindUI:Notify({
        Title = "Remote Spy",
        Content = "System started successfully!",
        Icon = "check",
        Duration = 3
    })
end

function stopRemoteSpy()
    for remote, original in pairs(RemoteData.OriginalFunctions) do
        restoreOriginalFunction(remote)
    end
    
    RemoteData.HookedRemotes = {}
    updateStatus()
    
    WindUI:Notify({
        Title = "Remote Spy",
        Content = "System stopped!",
        Icon = "power",
        Duration = 3
    })
end

function findAndHookAllRemotes()
    local services = {
        game:GetService("ReplicatedStorage"),
        game:GetService("ServerStorage"),
        game:GetService("ServerScriptService"),
        game:GetService("Players"),
        game:GetService("Workspace")
    }
    
    for _, service in pairs(services) do
        if service then
            for _, obj in pairs(service:GetDescendants()) do
                if isValidRemote(obj) then
                    hookRemote(obj)
                    addToFoundRemotes(obj)
                end
            end
        end
    end
    
    updateRemoteList()
end

function isValidRemote(obj)
    return obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") or obj:IsA("BindableEvent")
end

function hookRemote(remote)
    if RemoteData.HookedRemotes[remote] then return end
    
    if remote:IsA("RemoteEvent") then
        hookRemoteEvent(remote)
    elseif remote:IsA("RemoteFunction") then
        hookRemoteFunction(remote)
    elseif remote:IsA("BindableEvent") then
        hookBindableEvent(remote)
    end
    
    RemoteData.HookedRemotes[remote] = true
end

function hookRemoteEvent(remote)
    local original = remote.FireServer
    RemoteData.OriginalFunctions[remote] = original
    
    remote.FireServer = function(self, ...)
        local args = {...}
        logRemoteCall(remote, "RemoteEvent", args)
        
        if not shouldBlockRemote(remote, args) then
            return original(self, ...)
        else
            return nil
        end
    end
end

function hookRemoteFunction(remote)
    local original = remote.InvokeServer
    RemoteData.OriginalFunctions[remote] = original
    
    remote.InvokeServer = function(self, ...)
        local args = {...}
        logRemoteCall(remote, "RemoteFunction", args)
        
        if not shouldBlockRemote(remote, args) then
            return original(self, ...)
        else
            return nil
        end
    end
end

function hookBindableEvent(bindable)
    local original = bindable.Fire
    RemoteData.OriginalFunctions[bindable] = original
    
    bindable.Fire = function(self, ...)
        local args = {...}
        logRemoteCall(bindable, "BindableEvent", args)
        return original(self, ...)
    end
end

function shouldBlockRemote(remote, args)
    if not getgenv().RemoteSpy.AutoBlock then return false end
    
    local remoteName = remote.Name:lower()
    local suspiciousPatterns = {"kick", "ban", "punish", "reset", "crash", "exploit"}
    
    for _, pattern in ipairs(suspiciousPatterns) do
        if remoteName:find(pattern) then
            WindUI:Notify({
                Title = "ðŸš¨ Blocked Suspicious Remote",
                Content = "Blocked: " .. remote.Name,
                Icon = "shield-alert",
                Duration = 5
            })
            return true
        end
    end
    
    return false
end

function logRemoteCall(remote, callType, args)
    if not getgenv().RemoteSpy.LogCalls then return end
    
    local logEntry = {
        Timestamp = os.date("%X"),
        RemoteName = remote.Name,
        RemoteType = callType,
        Arguments = args,
        RemotePath = remote:GetFullName()
    }
    
    table.insert(RemoteData.Logs, 1, logEntry)
    
    -- Limit logs
    if #RemoteData.Logs > getgenv().RemoteSpy.MaxLogs then
        table.remove(RemoteData.Logs)
    end
    
    -- Print to console
    print(string.format("[%s] %s - %s", logEntry.Timestamp, logEntry.RemoteName, logEntry.RemoteType))
end

-- ========== SCANNING FUNCTIONS ==========

function performDeepScan()
    RemoteData.FoundRemotes = {}
    
    -- Scan all game services
    for _, service in pairs(game:GetChildren()) do
        scanServiceForRemotes(service)
    end
    
    updateRemoteList()
    
    WindUI:Notify({
        Title = "Deep Scan Complete",
        Content = "Found " .. #RemoteData.FoundRemotes .. " remotes",
        Icon = "search",
        Duration = 4
    })
    
    ResultsLabel:Set("Deep scan completed!\nFound " .. #RemoteData.FoundRemotes .. " remotes")
end

function scanServiceForRemotes(service)
    local success, result = pcall(function()
        for _, obj in pairs(service:GetDescendants()) do
            if isValidRemote(obj) then
                addToFoundRemotes(obj)
            end
        end
    end)
end

function scanScriptsForRemotes()
    WindUI:Notify({
        Title = "Script Scanner",
        Content = "Scanning scripts for remote usage...",
        Icon = "file-text",
        Duration = 3
    })
end

function addToFoundRemotes(remote)
    local remoteInfo = {
        Object = remote,
        Name = remote.Name,
        Type = remote.ClassName,
        Path = remote:GetFullName(),
        IsHooked = RemoteData.HookedRemotes[remote] or false
    }
    
    table.insert(RemoteData.FoundRemotes, remoteInfo)
end

-- ========== COPY FUNCTIONS ==========

function selectRemoteFromDropdown(option)
    if option == "No remotes found" then return end
    
    for _, remote in pairs(RemoteData.FoundRemotes) do
        if remote.Name == option then
            RemoteData.SelectedRemote = remote
            updateRemoteInfoDisplay(remote)
            WindUI:Notify({
                Title = "Remote Selected",
                Content = "Selected: " .. remote.Name,
                Icon = "check",
                Duration = 2
            })
            break
        end
    end
end

function copySelectedRemotePath()
    if not RemoteData.SelectedRemote then
        showNoRemoteSelectedError()
        return
    end
    
    setclipboard(RemoteData.SelectedRemote.Path)
    WindUI:Notify({
        Title = "Copied to Clipboard",
        Content = "Remote path copied!",
        Icon = "copy",
        Duration = 2
    })
end

function copySelectedRemoteName()
    if not RemoteData.SelectedRemote then
        showNoRemoteSelectedError()
        return
    end
    
    setclipboard(RemoteData.SelectedRemote.Name)
    WindUI:Notify({
        Title = "Copied to Clipboard",
        Content = "Remote name copied!",
        Icon = "copy",
        Duration = 2
    })
end

function copySelectedFireScript()
    if not RemoteData.SelectedRemote then
        showNoRemoteSelectedError()
        return
    end
    
    local remote = RemoteData.SelectedRemote
    local script = ""
    
    if remote.Type == "RemoteEvent" then
        script = string.format([[
-- Fire RemoteEvent: %s
local remote = game:GetService("ReplicatedStorage"):WaitForChild("%s")
if remote:IsA("RemoteEvent") then
    remote:FireServer()
    print("Fired RemoteEvent: %s")
end
        ]], remote.Name, remote.Name, remote.Name)
        
    elseif remote.Type == "RemoteFunction" then
        script = string.format([[
-- Invoke RemoteFunction: %s
local remote = game:GetService("ReplicatedStorage"):WaitForChild("%s")
if remote:IsA("RemoteFunction") then
    local result = remote:InvokeServer()
    print("Invoked RemoteFunction: %s - Result:", result)
end
        ]], remote.Name, remote.Name, remote.Name)
        
    elseif remote.Type == "BindableEvent" then
        script = string.format([[
-- Fire BindableEvent: %s
local bindable = game:GetService("ReplicatedStorage"):WaitForChild("%s")
if bindable:IsA("BindableEvent") then
    bindable:Fire()
    print("Fired BindableEvent: %s")
end
        ]], remote.Name, remote.Name, remote.Name)
    end
    
    setclipboard(script)
    WindUI:Notify({
        Title = "Copied to Clipboard",
        Content = "Fire script copied!",
        Icon = "copy",
        Duration = 2
    })
end

-- ========== UI UPDATE FUNCTIONS ==========

function updateStatus()
    local status = getgenv().RemoteSpy.Enabled and "ðŸŸ¢ ONLINE" or "ðŸ”´ OFFLINE"
    local statusText = string.format("%s\nHooked Remotes: %d\nTotal Logs: %d", 
        status, 
        getTableLength(RemoteData.HookedRemotes), 
        #RemoteData.Logs
    )
    StatusLabel:Set(statusText)
end

function updateRemoteList()
    local options = {"Select a remote..."}
    
    for _, remote in pairs(RemoteData.FoundRemotes) do
        table.insert(options, remote.Name)
    end
    
    RemoteDropdown:Refresh(options)
    ResultsLabel:Set("Found " .. #RemoteData.FoundRemotes .. " remotes")
end

function updateRemoteInfoDisplay(remote)
    local infoText = string.format("Name: %s\nType: %s\nPath: %s\nHooked: %s",
        remote.Name,
        remote.Type,
        remote.Path,
        tostring(remote.IsHooked)
    )
    RemoteInfoLabel:Set(infoText)
end

function showNoRemoteSelectedError()
    WindUI:Notify({
        Title = "Error",
        Content = "No remote selected!",
        Icon = "x",
        Duration = 2
    })
end

-- ========== UTILITY FUNCTIONS ==========

function getTableLength(t)
    local count = 0
    for _ in pairs(t) do count = count + 1 end
    return count
end

function quickScan()
    RemoteData.FoundRemotes = {}
    findAndHookAllRemotes()
    WindUI:Notify({
        Title = "Quick Scan Complete",
        Content = "Found " .. #RemoteData.FoundRemotes .. " remotes",
        Icon = "search",
        Duration = 3
    })
end

function clearLogs()
    RemoteData.Logs = {}
    updateStatus()
    WindUI:Notify({
        Title = "Logs Cleared",
        Content = "All logs have been cleared!",
        Icon = "trash",
        Duration = 2
    })
end

function blockAllRemotes()
    for remote, _ in pairs(RemoteData.HookedRemotes) do
        if remote:IsA("RemoteEvent") then
            remote.FireServer = function() end
        elseif remote:IsA("RemoteFunction") then
            remote.InvokeServer = function() return nil end
        end
    end
    WindUI:Notify({
        Title = "All Remotes Blocked",
        Content = "All remote calls are now blocked!",
        Icon = "shield",
        Duration = 3
    })
end

function unblockAllRemotes()
    for remote, original in pairs(RemoteData.OriginalFunctions) do
        if remote:IsA("RemoteEvent") then
            remote.FireServer = original
        elseif remote:IsA("RemoteFunction") then
            remote.InvokeServer = original
        end
    end
    WindUI:Notify({
        Title = "All Remotes Unblocked",
        Content = "All remote calls are now unblocked!",
        Icon = "shield-off",
        Duration = 3
    })
end

function exportSecurityReport()
    WindUI:Notify({
        Title = "Security Report",
        Content = "Security report exported!",
        Icon = "download",
        Duration = 3
    })
end

function restoreOriginalFunction(remote)
    local original = RemoteData.OriginalFunctions[remote]
    if original then
        if remote:IsA("RemoteEvent") then
            remote.FireServer = original
        elseif remote:IsA("RemoteFunction") then
            remote.InvokeServer = original
        elseif remote:IsA("BindableEvent") then
            remote.Fire = original
        end
    end
end

-- Initialize with a quick scan
spawn(function()
    wait(2)
    quickScan()
end)
